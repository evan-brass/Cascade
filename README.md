# Cascade

Cascade is my attempt at declerative model creation, and hopefully declerative view creation.  It draws heavily from Polymer's property-mixin's property syntax.  I also used one of the styles of injecting dependencies used by Angular to determine what properties are computed and what they depend on.

Anyway, it seems that there are two problems to solve when creating an MVC (I Haven't decided how to do the C part in Cascade yet) application.  Unidirectional data flow keeps a View in sync with a model and a controller makes changes to that model.  My experiences writing custom elements (and I'm inclined to believe that they're not unique) have been to write a model as a javascript class and call all of my 'update' functions that update the view from within my property setters.  The Cascade Model function does all of that logic automatically.  It takes an object of properties (examples are in the model.unit.js file) and creates a Directed Acyclic Graph that shows which properties depend (are computed from) other properties.

That's the part of Cascade which (based on some minimal testing) is functional.  Where I want it to be is at the end of a long road currently.  I want a View function which does the same thing that the Model does but for views.  The View function would create a document fragment of nodes which it manages.  Similiar to lit-html or hyperHTML except that instead of using computed expressions as the parts, each part would be a function with parameters (that can be parsed) declaring what properties (of a Model) that part needed.  This function would be a 'user' of the propteries it takes as parameters that are on the Model.  The Model would then propagate changes to those properties because they are actually being used/visible to the client.  This way only the computed properties which are actively being displayed are update.  Similiarly, a bunch of little functions are called on when their required properties change instead of one big render function being called upon any change that occurs to the Model.  I'm inclined to believe that this would be faster even though the declerative Model/View -> imperative Model/View adds a great deal of extra indevidual computation.  

Even if it isn't the fastest solution to the problem, my goal is to be a stab at the most efficient solution.  I think that we should be wary of a meer persuit of speed, potentially at the expense of memory use, or CPU use.  Each website is an invited (most of the time) guest on the user's computer.  I want to respect that user by not doing things just because I can.  Things like Service Workers are powerful technologies which shouldn't be abused or ubiquitous.  Some people will only visit a site once.  They're experience is hindered, not helped by a developer doing everything within their power.

True strength is power held under control and used to benefit of others.